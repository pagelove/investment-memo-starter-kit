<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Pagelove</title>
    <link rel="stylesheet" href="https://pagelove.org/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>
        #last-request {
            display: block;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }
        
        #last-request.visible {
            opacity: 1;
        }
    </style>
    <script type="module" src="https://pagelove.org/js/dom-primitives/index.mjs"></script>
    <script type="module" src="https://pagelove.org/js/runkit/index.mjs"></script>
    <script type="module" src="https://jamesaduncan.github.io/selector-subscriber/index.mjs"></script>
    <script type="module" src="./js/index.mjs"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/http.min.js"></script>
  </head>
  <body>
    <!-- Hero Section with ID for selector targeting -->
    <header class="fixed-header">
      <h1 class="header-title">Pagelove</h1>
    </header>

    <!-- Main Content Area -->
    <main>
        <section>
            <h1>Pagelove - what it's all about</h1>
            <p>
                Pagelove is a new way to think about building web applications, that's more like the old way.
            </p>
            <p>
                Because we have come to think of the web as an application delivery mechanism, the amount of
                tooling, frameworks, and libraries are needed to get started with anything is truly
                staggering. The rise of node.js APIs and single page applications, has moved us away
                from the foundational ideas of the web, into a world where the web is just a big dumb pipe.
            </p>
            <p>
                Pagelove enables surgical DOM manipulations using standard HTTP and HTML. This makes for
                much simpler applications, that don't require complex state management in the client.
            </p>
            <p>
                Go ahead, try it, edit the paragraph:
            </p>
            <p id="editable" contenteditable="plaintext-only">
                Make whatever change you'd like.<br></p>
            <p id="last-request">
                You can see from the HTTP message, just how simple it can be to edit a document on the web, with
                surgical precision:
                <network-last-request></network-last-request>
            </p>
        </section>
        <section>
            <h2>The business</h2>
            <p>
                But radically simpler applications aren't a business. The business of pagelove is 
                living at the edge. Because Pagelove doesn't need complex containers or serverless functions,
                it can be operated far less expensively than existing edge computing solutions. 
            </p>
            <p>
                <strong>
                    In a world of AI created software, where it is infinitely inexpensive
                    to build, the only thing that matters will be its operational cost.
                </strong>
            </p>
            <p>                
                Pagelove is the future of edge computing,  and the Pagelove Platform will be 
                where applications run.
            </p>
            <h2>Platform features</h2>
            <ul>
                <li>Simple surgical DOM manipulation using HTTP verbs</li>
                <li>Built in CDN, with automatic cache invalidation</li>
                <li>HTML Microdata-aware, enabling data-fanout</li>
                <li>Edge first architecture, with no complex containers or serverless functions</li>
                <li>Effortless websockets allowing real-time collaboration on <em>any</em> page</li>
            </ul>
        </section>
        <section>
            <h2>The team</h2>
        </section>
    </main>
    <script type="module">
        import { SelectorSubscriber } from "https://jamesaduncan.github.io/selector-subscriber/index.mjs";
        document.addEventListener("DASAvailable", async () => {
            
            let debounceTimer;
            
            // Helper to save cursor position
            function saveSelection() {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    return selection.getRangeAt(0);
                }
                return null;
            }
            
            // Helper to restore cursor position
            function restoreSelection(range) {
                if (range) {
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            SelectorSubscriber.subscribe('[contenteditable]', async (editable) => {
                // Initialize originalContent with the current content of the editable element
                let originalContent = editable.textContent;
                
                editable.addEventListener('input', async() => {
                    clearTimeout(debounceTimer);
                    const currentContent = editable.textContent;
                    
                    if (currentContent !== originalContent) {
                        debounceTimer = setTimeout(async () => {
                            // Get fresh content at save time, not when timeout was set
                            const latestContent = editable.textContent;
                            
                            // Save cursor position before PUT
                            const savedRange = saveSelection();
                            const hadFocus = document.activeElement === editable;
                            
                            const response = await editable.PUT();
                            if (response.ok) {
                                document.getElementById('last-request').classList.add('visible');
                                // Update originalContent with the actual saved content
                                originalContent = latestContent;
                            }
                            
                            // Restore focus and cursor after a brief delay to let DOM settle
                            if (hadFocus) {
                                setTimeout(() => {
                                    editable.focus();
                                    restoreSelection(savedRange);
                                }, 0);
                            }
                        }, 1500); // Triggers after 1.5 seconds of inactivity
                    }
                });
                
                // Still handle blur to ensure save on navigation
                editable.addEventListener('blur', async() => {
                    clearTimeout(debounceTimer);
                    const currentContent = editable.textContent;
                    
                    if (currentContent !== originalContent) {
                        const response = await editable.PUT();
                        if (response.ok) {
                            document.getElementById('last-request').classList.add('visible');
                        }
                        originalContent = currentContent;
                    }
                });

            })
        });
    </script>
</body></html>