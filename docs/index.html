<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Pagelove</title>
    <link rel="stylesheet" href="https://pagelove.org/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>
        #last-request {
            display: block;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }
        
        #last-request.visible {
            opacity: 1;
        }
    </style>
    <script type="module" src="https://pagelove.org/js/dom-primitives/index.mjs"></script>
    <script type="module" src="https://pagelove.org/js/runkit/index.mjs"></script>
    <script type="module" src="https://jamesaduncan.github.io/selector-subscriber/index.mjs"></script>
    <script type="module" src="./js/index.mjs"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/http.min.js"></script>
  </head>
  <body>
    <!-- Hero Section with ID for selector targeting -->
    <header class="fixed-header">
      <h1 class="header-title">Pagelove</h1>
    </header>

    <!-- Main Content Area -->
    <main>
        <section>
            <h1>Pagelove - documents power the web</h1>
            <p>
                Pagelove is a new way to think about the web, that's more like the old way.
            </p>
            <p>
                The clash between the document-centric web, and the web as an application
                delivery platform has meant an the amount of tooling, frameworks, and libraries requrired
                to build even simple tools has exploded. The rise of node.js APIs and single page
                applications, has moved us away from the foundational ideas of the web, into a world
                where the web is just a big dumb pipe.
            </p>
            <p>
                Pagelove enables surgical DOM manipulations using standard HTTP and HTML, transforming
                the web from a dumb pipe into a razar-sharp scalpel.
            </p>
            <p>
                Go ahead, try it, edit this paragraph:
            </p>
            <p id="editable" contenteditable="plaintext-only">
                Make whatever change you'd like.<br></p>
            <p id="last-request">
                You can see from the HTTP message just how simple an edit can be:
                <network-last-request></network-last-request>
            </p>
        </section>
        <section>
            <h2>The business</h2>
            <p>
                But radically simpler applications aren't a business. The business of Pagelove is 
                living at the edge. Pagelove can be operated far less expensively than existing
                edge computing solutions because it doesn't need complex containers or serverless
                functions.
            </p>
            <p>
                <strong>
                    In an AI world, where it is infinitely inexpensive
                    to build software, the only thing that matters will be its operational cost.
                </strong>
            </p>
            <p>                
                Pagelove is the future of edge computing, and the Pagelove Platform will be 
                where applications run.
            </p>
            <h2>Platform features</h2>
            <ul>
                <li>Simple surgical DOM manipulation using HTTP verbs</li>
                <li>Built in CDN, with automatic cache invalidation</li>
                <li>HTML Microdata-aware, enabling data-fanout</li>
                <li>Edge first architecture, with no complex containers or serverless functions</li>
                <li>Effortless websockets allowing real-time collaboration on <em>any</em> page</li>
            </ul>
        </section>
    </main>
    <script type="module">
        import { SelectorSubscriber } from "https://jamesaduncan.github.io/selector-subscriber/index.mjs";
        document.addEventListener("DASAvailable", async () => {
            
            let debounceTimer;
            
            // Helper to save cursor position
            function saveSelection() {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    return selection.getRangeAt(0);
                }
                return null;
            }
            
            // Helper to restore cursor position
            function restoreSelection(range) {
                if (range) {
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            SelectorSubscriber.subscribe('[contenteditable]', async (editable) => {
                // Initialize originalContent with the current content of the editable element
                let originalContent = editable.textContent;
                
                editable.addEventListener('input', async() => {
                    clearTimeout(debounceTimer);
                    const currentContent = editable.textContent;
                    
                    if (currentContent !== originalContent) {
                        debounceTimer = setTimeout(async () => {
                            // Get fresh content at save time, not when timeout was set
                            const latestContent = editable.textContent;
                            
                            // Save cursor position before PUT
                            const savedRange = saveSelection();
                            const hadFocus = document.activeElement === editable;
                            
                            const response = await editable.PUT();
                            if (response.ok) {
                                document.getElementById('last-request').classList.add('visible');
                                // Update originalContent with the actual saved content
                                originalContent = latestContent;
                            }
                            
                            // Restore focus and cursor after a brief delay to let DOM settle
                            if (hadFocus) {
                                setTimeout(() => {
                                    editable.focus();
                                    restoreSelection(savedRange);
                                }, 0);
                            }
                        }, 1500); // Triggers after 1.5 seconds of inactivity
                    }
                });
                
                // Still handle blur to ensure save on navigation
                editable.addEventListener('blur', async() => {
                    clearTimeout(debounceTimer);
                    const currentContent = editable.textContent;
                    
                    if (currentContent !== originalContent) {
                        const response = await editable.PUT();
                        if (response.ok) {
                            document.getElementById('last-request').classList.add('visible');
                        }
                        originalContent = currentContent;
                    }
                });

            })
        });
    </script>
</body></html>